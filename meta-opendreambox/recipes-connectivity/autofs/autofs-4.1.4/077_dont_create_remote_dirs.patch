#!/bin/sh /usr/share/dpatch/dpatch-run
## 077_dont_create_remote_dirs.dpatch
##
## DP: No description.

@DPATCH@

diff -Naur .B/daemon/automount.c .A/daemon/automount.c
--- .B/daemon/automount.c	2005-03-06 09:43:55.000000000 +0000
+++ .A/daemon/automount.c	2007-01-07 21:36:36.000000000 +0000
@@ -79,6 +79,32 @@
 static int handle_packet_expire(const struct autofs_packet_expire *pkt);
 static int umount_all(int force);
 
+static int do_mkdir(const char *path, mode_t mode)
+{
+	int status;
+	struct stat st;
+
+	status = stat(path, &st);
+	if (status == 0) {
+		if (!S_ISDIR(st.st_mode)) {
+			errno = ENOTDIR;
+			return 0;
+		}
+		return 1;
+	}
+
+	if (contained_in_local_fs(path)) {
+		if (mkdir(path, mode) == -1) {
+			if (errno == EEXIST)
+				return 1;
+			return 0;
+		}
+		return 1;
+	}
+
+	return 0;
+}
+
 int mkdir_path(const char *path, mode_t mode)
 {
 	char *buf = alloca(strlen(path) + 1);
@@ -91,19 +117,9 @@
 			bp += cp - lcp;
 			lcp = cp;
 			*bp = '\0';
-			if (mkdir(buf, mode) == -1) {
-				/* If it already exists, make sure it's a directory */
-				if (errno == EEXIST) {
-					struct stat st;
-
-					if (stat(buf, &st) == 0 && !S_ISDIR(st.st_mode))
-						errno = ENOTDIR;
-					else {
-						/* last component, return -1 */
-						if (*cp != '\0')
-							continue;
-					}
-				}
+			if (!do_mkdir(buf, mode)) {
+				if (*cp != '\0')
+					continue;
 				return -1;
 			}
 		}
diff -Naur .B/include/automount.h .A/include/automount.h
--- .B/include/automount.h	2007-01-07 21:36:36.000000000 +0000
+++ .A/include/automount.h	2007-01-07 21:36:36.000000000 +0000
@@ -34,6 +34,8 @@
 #define SLOPPY
 #endif
 
+#define AUTOFS_SUPER_MAGIC 0x00000187L
+
 #define DEFAULT_TIMEOUT (5*60)			/* 5 minutes */
 #define AUTOFS_LOCK	"/var/lock/autofs"	/* To serialize access to mount */
 #define MOUNTED_LOCK	_PATH_MOUNTED "~"	/* mounts' lock file */
@@ -272,6 +274,7 @@
 /* mount table utilities */
 struct mnt_list {
 	char *path;
+	char *fs_name;
 	char *fs_type;
 	pid_t pid;
 	time_t last_access;
@@ -282,6 +285,7 @@
 struct mnt_list *reverse_mnt_list(struct mnt_list *list);
 struct mnt_list *get_base_mnt_list(struct mnt_list *list);
 void free_mnt_list(struct mnt_list *list);
+int contained_in_local_fs(const char *path);
 int is_mounted(const char *table, const char *path);
 int has_fstab_option(const char *path, const char *opt);
 int allow_owner_mount(const char *);
diff -Naur .B/lib/mounts.c .A/lib/mounts.c
--- .B/lib/mounts.c	2005-01-17 15:09:28.000000000 +0000
+++ .A/lib/mounts.c	2007-01-07 21:36:36.000000000 +0000
@@ -21,6 +21,7 @@
 #include <limits.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/vfs.h>
 #include <stdio.h>
 
 #include "automount.h"
@@ -35,7 +36,6 @@
 	struct mntent *mnt;
 	struct mnt_list *ent, *mptr, *last;
 	struct mnt_list *list = NULL;
-	struct stat st;
 	int len;
 
 	if (!path || !pathlen || pathlen > PATH_MAX)
@@ -91,6 +91,14 @@
 		}
 		strcpy(ent->path, mnt->mnt_dir);
 
+		ent->fs_name = malloc(strlen(mnt->mnt_fsname) + 1);
+		if (!ent->fs_name) {
+			endmntent(tab);
+			free_mnt_list(list);
+			return NULL;
+		}
+		strcpy(ent->fs_name, mnt->mnt_fsname);
+
 		ent->fs_type = malloc(strlen(mnt->mnt_type) + 1);
 		if (!ent->fs_type) {
 			endmntent(tab);
@@ -105,16 +113,6 @@
 	}
 	endmntent(tab);
 
-	mptr = list;
-	while (mptr) {
-		mptr->last_access = time(NULL);
-
-		if (stat(mptr->path, &st) != -1)
-			mptr->last_access = st.st_atime;
-
-		mptr = mptr->next;
-	}
-
 	return list;
 }
 
@@ -242,6 +240,9 @@
 		if (this->path)
 			free(this->path);
 
+		if (this->fs_name)
+			free(this->fs_name);
+
 		if (this->fs_type)
 			free(this->fs_type);
 
@@ -282,7 +283,48 @@
 
 	return ret;
 }
-	
+
+int contained_in_local_fs(const char *path)
+{
+	struct mnt_list *mnts, *this;
+	size_t pathlen = strlen(path);
+	struct statfs fs;
+	int rv, ret;
+
+	if (!path || !pathlen || pathlen > PATH_MAX)
+		return 0;
+
+	mnts = get_mnt_list(_PATH_MOUNTED, "/", 1);
+	if (!mnts)
+		return 0;
+
+	ret = 0;
+
+	for (this = mnts; this != NULL; this = this->next) {
+		size_t len = strlen(this->path);
+
+		if (!strncmp(path, this->path, len)) {
+			if (len > 1 && pathlen > len && path[len] != '/')
+				continue;
+			rv = statfs(this->path, &fs);
+			if (rv != -1 && fs.f_type == AUTOFS_SUPER_MAGIC)
+				ret = 1;
+			else if (this->fs_name[0] == '/') {
+				if (strlen(this->fs_name) > 1) {
+					if (this->fs_name[1] != '/')
+						ret = 1;
+				} else
+					ret = 1;
+			}
+			break;
+		}
+	}
+
+	free_mnt_list(mnts);
+
+	return ret;
+}
+
 int is_mounted(const char *table, const char *path)
 {
 	int ret = 0;
